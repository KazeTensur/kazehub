-- ================= KAZEHUB FINAL FIXED REWARD VERSION =================
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
    Name = "KazeHub!",
    Icon = 0,
    LoadingTitle = "Welcome to KazeHub!",
    LoadingSubtitle = "by Kaze",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "Kazehub",
        FileName = "kazehub"
    }
})

-- ================= SERVICES =================
local Players = game:GetService("Players")
local lp = Players.LocalPlayer
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local VirtualUser = game:GetService("VirtualUser")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

local RemoteEvent = game:GetService("ReplicatedStorage")
    :WaitForChild("API")
    :WaitForChild("Utils")
    :WaitForChild("network")
    :WaitForChild("RemoteEvent")

local WorldsFolder = workspace:WaitForChild("Worlds", 10)

-- ================= STATE =================
local SelectedMode = "Story"
local SelectedMap = nil
local SelectedAct = 1
local SelectedDifficulty = "Normal"
local RaidMaps = {"Vastora Realm","Ember Village","Power Arena"}

local customWebhook = ""
local WebhookEnabled = true
local AutoJoinEnabled = false
local AutoChallengeEnabled = false
local AutoEquipTeam = false
local IgnoredDebuffs = {}

local s_request = (syn and syn.request) or (http and http.request) or http_request or request

-- ================= LOAD WEBHOOK =================
pcall(function()
    if isfile("custom_webhook.txt") then
        customWebhook = readfile("custom_webhook.txt")
    end
end)

-- ================= HELPER FUNCTIONS =================
local function getSortedMaps()
    local list = {}
    if WorldsFolder then
        for _, map in ipairs(WorldsFolder:GetChildren()) do
            if map:IsA("Model") or map:IsA("Folder") then
                table.insert(list, map.Name)
            end
        end
    end
    table.sort(list, function(a,b) return a:lower() < b:lower() end)
    return list
end

local function getTotalBalance()
    local data = lp:FindFirstChild("Data")
    if not data then return "N/A" end
    return string.format("üí∞ Coins: %s\nüíé Gems: %s", data.Coins.Value, data.Gems.Value)
end

local function isPlayerInBattle()
    local battleGui = lp.PlayerGui:FindFirstChild("battle")
    return battleGui and battleGui.Enabled or false
end

-- H√ÄM QU√âT REWARD M·ªöI (FIXED)
local function getMatchRewards()
    local rewards = {}
    pcall(function()
        local rewardList = lp.PlayerGui.battle.Result.Base.Content.Rewards:FindFirstChild("List")
        if rewardList then
            for _, item in ipairs(rewardList:GetChildren()) do
                -- Ch·ªâ l·∫•y Frame/ImageLabel v√† b·ªè qua c√°c UI Layout
                if (item:IsA("Frame") or item:IsA("ImageLabel")) and item.Name ~= "UIListLayout" then
                    local name = item.Name
                    local amount = item:FindFirstChild("Amount") and item.Amount.Text or "1"
                    table.insert(rewards, "üì¶ " .. name .. ": x" .. amount)
                end
            end
        end
    end)
    
    if #rewards > 0 then
        return table.concat(rewards, "\n> ")
    else
        return "No items dropped"
    end
end

-- ================= FARM ACTIONS =================
local function runAutoJoin()
    if not SelectedMap then return end
    if SelectedMode == "Story" then
        RemoteEvent:FireServer("battle_start", "story", SelectedMap, SelectedAct, SelectedDifficulty)
    elseif SelectedMode == "Raid" then
        local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
        local raidFolder = workspace:WaitForChild("Rooms"):WaitForChild("raid")
        for _, roomModel in ipairs(raidFolder:GetChildren()) do
            local touchPart = roomModel:FindFirstChild("Touch", true)
            if touchPart and hrp then
                firetouchinterest(hrp, touchPart, 0)
                task.wait(0.1)
                firetouchinterest(hrp, touchPart, 1)
                task.wait(0.5)
                RemoteEvent:FireServer("room_select", SelectedMap, 1)
                task.wait(0.3)
                RemoteEvent:FireServer("room_start")
                break
            end
        end
    end
end

-- ================= SMART CHALLENGE LOGIC =================
local function getLiveChallengeData()
    local success, result = pcall(function()
        local baseUI = workspace.Lobby.ChallengeInfo["Semi-Hourly"].Model.Part.SurfaceGui.Base
        return { Map = baseUI.MapName.Text, Debuff = baseUI.Debuff.Text }
    end)
    return success and result or {Map = "N/A", Debuff = "N/A"}
end

local function joinChallengeRoom()
    local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    local touchPart = workspace.Rooms.challenges.Model.Touch
    local liveData = getLiveChallengeData()
    if hrp and touchPart and liveData.Map ~= "N/A" then
        if AutoEquipTeam then
            RemoteEvent:FireServer("equip_team", 1)
            task.wait(1.2)
        end
        hrp.CFrame = touchPart.CFrame * CFrame.new(0, 2, 0)
        task.wait(0.2)
        firetouchinterest(hrp, touchPart, 0)
        task.wait(0.1)
        firetouchinterest(hrp, touchPart, 1)
        task.wait(0.8)
        RemoteEvent:FireServer("room_select", liveData.Map, 7, { ["ChallengeType"] = "Semi-Hourly", ["Debuff"] = liveData.Debuff })
        task.wait(0.5)
        RemoteEvent:FireServer("room_start")
    end
end

-- ================= UI TABS =================
local Main = Window:CreateTab("Lobby / Farm", 4483362458)
local MapDropdown

Main:CreateDropdown({
    Name = "1. Select Mode",
    Options = {"Story","Raid"},
    CurrentOption = {"Story"},
    Callback = function(opt)
        SelectedMode = opt[1]
        if MapDropdown then MapDropdown:Refresh(SelectedMode == "Raid" and RaidMaps or getSortedMaps(), true) end
    end
})

MapDropdown = Main:CreateDropdown({
    Name = "2. Select Map",
    Options = getSortedMaps(),
    CurrentOption = {},
    Callback = function(opt) SelectedMap = opt[1] end
})

Main:CreateDropdown({
    Name = "3. Select Act",
    Options = {"1","2","3","4","5","6","7","8","9","10"},
    CurrentOption = {"1"},
    Callback = function(opt) SelectedAct = tonumber(opt[1]) end
})

Main:CreateDropdown({
    Name = "4. Difficulty",
    Options = {"Normal","Hard","Nightmare"},
    CurrentOption = {"Normal"},
    Callback = function(opt) SelectedDifficulty = opt[1] end
})

Main:CreateSection("Automation")

Main:CreateToggle({
    Name = "Auto Join & Start",
    CurrentValue = false,
    Callback = function(val) 
        AutoJoinEnabled = val 
        if val and not isPlayerInBattle() then runAutoJoin() end
    end
})

local ChallengeTab = Window:CreateTab("Challenges", 4483362458)
ChallengeTab:CreateSection("Team Management")
ChallengeTab:CreateToggle({ Name = "Auto Equip Challenge Team", CurrentValue = false, Callback = function(val) AutoEquipTeam = val end })
ChallengeTab:CreateSection("Challenge Filter")
ChallengeTab:CreateDropdown({ Name = "Ignore Debuffs", Options = {"Double Stats", "Weakened Units", "Burn Enemies", "Poison Enemies"}, CurrentOption = {}, MultipleOptions = true, Callback = function(Options) IgnoredDebuffs = Options end })
local ChalStatus = ChallengeTab:CreateLabel("Status: Waiting...")
ChallengeTab:CreateToggle({ Name = "Smart Auto Challenge", CurrentValue = false, Callback = function(val)
    AutoChallengeEnabled = val
    if val then
        task.spawn(function()
            while AutoChallengeEnabled do
                if not isPlayerInBattle() then
                    local data = getLiveChallengeData()
                    ChalStatus:Set("Map: "..data.Map.." | Debuff: "..data.Debuff)
                    local isIgnored = false
                    for _, skip in ipairs(IgnoredDebuffs) do if data.Debuff:find(skip) then isIgnored = true break end end
                    if not isIgnored and data.Map ~= "N/A" then joinChallengeRoom() end
                end
                task.wait(15)
            end
        end)
    end
end })

local Tab2 = Window:CreateTab("Webhook", 4483362458)
Tab2:CreateToggle({ Name = "Enable Webhook", CurrentValue = true, Callback = function(v) WebhookEnabled = v end })
Tab2:CreateInput({ Name = "Link Webhook", CurrentValue = customWebhook, PlaceholderText = "Webhook link...", Callback = function(txt) customWebhook = txt end })
Tab2:CreateButton({ Name = "Save Webhook", Callback = function() writefile("custom_webhook.txt", customWebhook) end })

local MiscTab = Window:CreateTab("Misc", 4483362458)
MiscTab:CreateToggle({ Name = "Anti-AFK", CurrentValue = false, Callback = function(Value)
    if Value then _G.AFK = lp.Idled:Connect(function() VirtualUser:CaptureController() VirtualUser:ClickButton2(Vector2.new(0,0)) end)
    else if _G.AFK then _G.AFK:Disconnect() end end
end })
MiscTab:CreateButton({ Name = "Rejoin", Callback = function() TeleportService:Teleport(game.PlaceId, lp) end })

-- ================= FINAL BEAUTIFIED WEBHOOK LOGIC =================
local function sendDiscord()
    if not WebhookEnabled or customWebhook == "" or customWebhook == " " then return end
    local proxyUrl = customWebhook:gsub("discord.com", "webhook.lewisakura.moe")
    
    local success, content = pcall(function() return lp.PlayerGui.battle.Result.Base.Content end)
    if not success then return end

    local rawResult = content.Result.Text
    local isWin = rawResult:lower():find("win") or rawResult:lower():find("victory")
    
    local final_payload = {
        ["embeds"] = {{
            ["title"] = isWin and "üèÜ " .. rawResult:upper() or "üíÄ " .. rawResult:upper(),
            ["color"] = isWin and 524287 or 16711680,
            ["description"] = "### " .. content.Stage.Text,
            ["fields"] = {
                {
                    ["name"] = "üìä **Balance**",
                    ["value"] = "```" .. getTotalBalance():gsub("üí∞ ", ""):gsub("üíé ", "") .. "```",
                    ["inline"] = false
                },
                {
                    ["name"] = "üéÅ **Rewards**",
                    ["value"] = "> " .. getMatchRewards(),
                    ["inline"] = false
                }
            },
            ["author"] = {
                ["name"] = "KazeHub Result: " .. lp.Name,
                ["icon_url"] = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. lp.UserId .. "&width=420&height=420&format=png"
            },
            ["footer"] = { ["text"] = "Time: " .. os.date("%X") .. " | KazeHub" }
        }}
    }

    task.spawn(function()
        pcall(function()
            s_request({
                Url = proxyUrl,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = HttpService:JSONEncode(final_payload)
            })
        end)
    end)
end

local sent = false
task.spawn(function()
    while true do
        task.wait(1)
        local battleGui = lp.PlayerGui:FindFirstChild("battle")
        local resultUI = battleGui and battleGui:FindFirstChild("Result")
        if resultUI then
            local isVisible = false
            pcall(function() isVisible = resultUI.Visible end)
            if isVisible then
                if not sent then
                    sent = true
                    task.wait(3) -- TƒÉng th·ªùi gian ƒë·ª£i ph·∫ßn th∆∞·ªüng load
                    sendDiscord()
                end
            else
                sent = false
            end
        end
    end
end)

Rayfield:LoadConfiguration()
